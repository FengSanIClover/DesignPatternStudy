Open/Close Principle (OCP) 開放/封閉原則
(Software entities (class, modules, functions, etc.) should be open for extension, but closed for modification.)
(軟體實體應該對擴充開放，對修改封閉)

對擴充開放：新功能是用寫新的程式碼擴充出來的。
對修改封閉：新功能不用修改現有程式碼。

軟體應該要保留彈性，可以擴充新功能，藉由增加新的程式碼來擴充系統的功能，
而不是藉由修改原本已經存在的程式碼來擴充系統的功能。
當需求有異動時，要如何在不變動現在正常運行的程式碼，藉由繼承、相依性注入等方式，增加新的程式碼，以實作新的需求。
假若為了新需求，去修改了原本的程式中的某一個函數，可能會造成其他呼叫使用該函數的的功能，出現非預期的錯誤。

以車來說，要開車在雪地上行駛，可以為輪胎綁上雪鍊(擴充開放)，而不是將整個輪胎換掉(修改封閉)。

實現 OCP 關鍵在於抽象，抽象出來的東西是不變的，具體的實現繼承於抽象，所以保證了對修改的封閉，
而抽象的實現方式有多種，可以隨需新增，當然這也就是對擴充套件的開放。 

此原則是設計模式六大原則的核心原則，其他五原則都是以此原則做實現化，也是物件導向設計的終極目標。
兩種安全的實現開閉原則的設計模式是：
Strategy pattern（策略模式)，Template Methord（模版方法模式）。

NationalTaxAdministration : 尚未實現開放/封閉原則的類別
INotify : 抽離方法的介面
Letter : 繼承介面實作方法的類別 
TextMessage : 繼承介面實作方法的類別 
ReNationalTaxAdministration : 實現開放/封閉原則的類別


優點
1.降低耦合。
2.增加擴展性。
3.增加可測試性。
4.擴展之前的邏輯，提高了代碼復用性。
5.提身維護性:最好的維護方法是透過延展，而不是一直修改原本的程式碼，否則原本程式碼越改越多、複雜時，
  會造成日後維護更加困難。
最大的好處正是降低修改風險。
開放封閉在大型或複雜專案上是非常有感覺的，只要是相同類型對處理方式不同的，就可以思考是否遵守 OCP。

潛在問題
擴展的情境並不一定在設計階段就會發現，常常要到了需求調整才會知道，像上面的範例正是如此，
透過重構讓設計可以更符合需求。

實際情況下當判斷的case只有一兩個時可以不用刻意去解耦合，因為設計上可能還沒完全，或者提早優化，
如果利用經驗來做提前預測，大多情況下會預測失誤，畢竟遵循OCP的成本很高也會增加不必要的複雜。

在書中提到，可以一直等到變化發生，也就是被搞過一次，這時候在進行隔離，一但隔離開來，之後有 BUG 也可以快速找到問題，
對於問題的修改不用擔心去連動到其他意料之外的地方，就會減少大量技術債。

參考資料 https://ithelp.ithome.com.tw/articles/10192105
		 https://www.itread01.com/content/1546737692.html
		 https://medium.com/@f40507777/%E9%96%8B%E6%94%BE%E5%B0%81%E9%96%89%E5%8E%9F%E5%89%87-open-closed-principle-31d61f9d37a5

